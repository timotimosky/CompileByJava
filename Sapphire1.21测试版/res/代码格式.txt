using namespace std;//沿用C++的名称空间的设置。
名称空间的使用:查找一个类如果有名称空间的设置，那么会先在名称空间里寻找这个对象，如果没找到则会在
默认的对象库中去寻找这个对象。


//这是一个代码的格式文件，主要确定代码的格式以方便编译。
//这个解释器主要运用于java的脚本，因此这类类有本地类，就是一个java类，因此会出现
native修饰。同时一些语言文件应该是最终类的final修饰也要使用。class关键字表示一个类必须拥有。
为了知道native文件的地方，系统定义了一个nativepath变量，指出了本地class文件的文件夹，注意:
本地class文件名为 类名+"class"。除非你显示的书名本地的类文件。(相对路径+全文件名)。
由于这种语言是完全面向对象的动态解释性语言，所以只有继承，并且只有单继承。
'native'(相对路径+全文件名)''   'final'   class System < Object {

	native [...]create(one);//这个方法一般是本地的方法，因为在这个方法中要传递一个字符串对象。
	这个方法会返回一个本地类的对象。这个对象就是所创建的字面值对象。
	字面值对象分为:小数double，整数long,字符串String,字符char,真假true false.
	当然还有两个内置类型，数组array,Hash表hash.
	
	def static(){}这个方法一般是没有参数的，当然你在加载的时候使用参数也没用，解释器在加载的时候
	会忽略参数。
	
	def new(){}//new方法也是一个很特别的方法，他是产生这个对象的一个复制对象的方法，他会先复制
	执行的对象，在复制后的对象上执行这个方法的代码，并且会返回复制的对象。
	
	....
	当然在传递参数的时候，你也可以传递一个本地类的参数，解释器会把你选择的本地类中的对象包装
	为一个SappClass对象，类的名字是一个特殊的java名字。这个SappClass的object属性就是表示的
	这个对象。同样用标记<> ，比如: a.test(<...>,"string");//第一个参数就是表示一个本地类对象
	的引用。方法可以被标记为同步的方法。就在native或者 def的后面，synchronized。同时支持同步代码
	块。
}
//大括号包括的为一个段

//对象加载段。
load{
	这里是处理加载的类对象，前面是类名后面是路径，记住这个路径为相对路径。
	Point="lang/...";
	...
}

//代码执行段，这个段为执行这个文件的代码，加载的时候会编译这个代码。如果重复加载begin段会覆盖。
begin{
	//其中的语句或块主要分为以下几类:
	1.直接的一个语句: 23*$a;Point.new();
	2.直接的赋值语句:a = 10; b = 23+5; $a = Point.new();
	3.流程控制语句:
	do{...}while(...);for(...;...;...){...} if(...){...}else if(...){...}else{...}
	while(...){...} switch(...){...} try{...}catch(...){...}
	其中涉及到几个重要的控制语句，
	return;返回的意思，在方法中直接退出，因为这个是一个动态的语言所以都可以用return语句而不
	带任何返回值。当然可以带返回值: return ‘表达式’;这个表达式的值会在方法变量空间中储存为一个
	return的变量。
	break与continue同样是在循环控制中使用。
	throw抛出语句，抛出的是一个对象:
	try{
		throw '($myexp)' "异常";//这里抛出了一个‘异常’字符串对象。并且保存到了全局变量中
		($myexp)是可以没有的，如果没有则这个异常对象是以$exception为命的。注意:异常名一般定义
		在全局变量中因为可能随着异常的抛出是异常对象所对应的作用空间失效。
	}catch(/*这里为一个表达式，如果有异常抛出那么就会确定这个表达式的真值，为真就执行异常
	代码。*/){
	
	}
}

优化本地方法构造。

引入名称空间概念，防止类名冲突。
关键字namespace 空间名{...内容只能是类}

同样注释说明:使用#注释每一行。使用/***/注释一段，不能嵌套。